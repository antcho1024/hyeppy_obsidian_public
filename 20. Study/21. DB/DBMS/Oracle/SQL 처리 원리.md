
- [[#Select 쿼리 처리|Select 쿼리 처리]]
	- [[#Select 쿼리 처리#SQL 처리 흐름|SQL 처리 흐름]]
		- [[#SQL 처리 흐름#SQL 분석|SQL 분석]]
			- [[#SQL 분석#CBO와 옵티마이저 통계|CBO와 옵티마이저 통계]]
		- [[#SQL 처리 흐름#SQL 실행|SQL 실행]]
		- [[#SQL 처리 흐름#로우 취득 (select문일 때만)|로우 취득 (select문일 때만)]]
	- [[#Select 쿼리 처리#실행 계획 확인해보기|실행 계획 확인해보기]]
	- [[#Select 쿼리 처리#분석된 SQL 정보의 보관과 공유|분석된 SQL 정보의 보관과 공유]]
	- [[#Select 쿼리 처리#데이터베이스 버퍼 캐시의 역할과 효과|데이터베이스 버퍼 캐시의 역할과 효과]]
	- [[#Select 쿼리 처리#캐시 기능 확인|캐시 기능 확인]]
	- [[#Select 쿼리 처리#인덱스 효과|인덱스 효과]]
	- [[#Select 쿼리 처리#정렬 수행과 PGA, 임시 테이블스페이스|정렬 수행과 PGA, 임시 테이블스페이스]]
- [[#변경 처리 원리|변경 처리 원리]]
	- [[#변경 처리 원리#트랜잭션 실행시 동작|트랜잭션 실행시 동작]]
	- [[#변경 처리 원리#체크 포인트|체크 포인트]]
		- [[#체크 포인트#비정상 종료|비정상 종료]]
	- [[#변경 처리 원리#트랜잭션 실행시 동작 확인|트랜잭션 실행시 동작 확인]]


### Select 쿼리 처리
![[SQL 처리 원리-20250102134402051.webp]]

- 쿼리 처리: 서버 프로세스
- 처리과정에서 사용되는 애들 :  SGA의 공유 풀, 데이터 베이스 버퍼 캐시, 인덱스, PGA 그리고 임시 테이블 스페이스
-> 같은 결과를 반환하는 SQL이어도 SQL 작성법, 메모리 사용방법에 따라 성능이 달라짐.
-> 실제 시스템 구축 현장에서는 성능이 매우 중요한 요건
-> 이번 장의 내용을 충분히 이해해 적절한 쿼리를 작성 해보자!

#### SQL 처리 흐름
쿼리 처리 : 서버 프로세스
서버 프로세스가 수행하는 SQL 처리는 아래 단계 3가지로 나뉨

분석 -> 실행 -> 추출

![[SQL 처리 원리-20250102135734111.webp]]
티베로와 동일 (공유풀 -> *PP, DD*) [[Tibero Architecture]]
##### SQL 분석
- 뭔지?
  서버프로세스는 SQL을 실행하기 전에 SQL문을 분석해 문법적인 에러가 없는지, 어떤 방식으로 SQL을 실행하는지, 사용하는 테이블/컬럼이 존재하는지 확인
- Why?
  SQL의 실행 방법을 나타내는 실행계획을 만드는 것

🥦 공유 풀 확인
(공유풀: 라이브러리 캐시, 딕셔너리 캐시, 리절트 캐시 [[Architecture (Tibero와 비교)]])
전달 받은 SQL과 같은 SQL의 분석 결과가 공유 풀에 있는지 확인함.
존재하면<font color="#9bbb59"> SQL 검정</font>, <font color="#9bbb59">실행 계획 수립</font> 과정 생략 > 바로 실행 ( -> 소프트 파싱 과정)

🥦SQL 검증
SQL 실행 가능한지 확인 
-  Syntax Check: 문법적 에러 있는지
-  Semantic Check: 지정된 테이블/컬럼 있는지
에러가 있을경우 클라이언트에 에러 회신, 처리 종료

🥦실행 계획 생성
실행이 가능하다고 판단되면, **실행계획**을 생성함
SQL 에는 구체적인 실행 순서를 지정할 수 없기 때문에 오라클은 실행 계획을 작성해 구체적인 실행 순서를 결정함.

> [!실행 계획]
> 오퍼레이션(SQL 실행 계획 내에서 수행되는 개별 작업 또는 단계)의 조합을 의미
> SQL 성능에 문제 생김! 👉 튜닝! 
튜닝시 실행계획을 확인함.

> [!오퍼레이션]
> - 데이터를 얻어오기 위해 수행하는 작업
>- 액세스 패스, 조인 등

![[SQL 처리 원리-20250107173334948.webp]]

![[SQL 처리 원리-20250107173353360.webp]]

```Text
#### 1. **데이터 접근 관련 오퍼레이션**

- **TABLE ACCESS FULL**: 테이블 전체를 스캔하여 데이터를 읽는 작업.
- **TABLE ACCESS BY INDEX ROWID**: 인덱스를 통해 테이블의 특정 행을 접근.
- **INDEX UNIQUE SCAN**: 유니크 인덱스를 사용하여 하나의 값을 정확히 검색.
- **INDEX RANGE SCAN**: 인덱스를 사용하여 조건에 맞는 데이터 범위를 검색.
- **INDEX FULL SCAN**: 전체 인덱스를 순차적으로 검색.

#### 2. **조인 관련 오퍼레이션**

- **NESTED LOOPS**: 두 테이블을 조인할 때 작은 테이블의 각 행에 대해 큰 테이블을 반복적으로 검색.
- **HASH JOIN**: 큰 테이블을 해시 테이블로 변환하여 조인.
- **MERGE JOIN**: 두 테이블이 정렬된 상태에서 병합을 통해 조인.

#### 3. **정렬 및 집계 관련 오퍼레이션**

- **SORT ORDER BY**: ORDER BY 절에 따라 데이터를 정렬.
- **SORT GROUP BY**: GROUP BY 절에 따라 데이터를 그룹화.
- **SORT UNIQUE**: DISTINCT 또는 중복 제거 작업 수행.

#### 4. **필터링 관련 오퍼레이션**

- **FILTER**: WHERE 절을 기반으로 데이터를 필터링.
- **VIEW**: 뷰에 정의된 논리적 데이터를 처리.

#### 5. **합산 및 집계 관련 오퍼레이션**

- **AGGREGATE**: 집계 함수(예: SUM, COUNT, AVG)를 수행.
- **COUNT STOPKEY**: 특정 조건에서 행 수를 계산하는 작업.
```

###### CBO와 옵티마이저 통계
- CBO(Cost-Based Optimizer: 비용 기반 옵티마이저)
- 서버 프로세스에 내장되어 있는 모듈
- 실행 계획 생성함.

**CBO**
CBO는 <font color="#9bbb59">분석 대상의 SQL문</font>과 <font color="#9bbb59">SQL에서 사용 하는 오브젝트의 옵티마이저 통계</font>를 바탕으로 실행 계획을 생성
- CBO가 실행 계획을 생성하는 과정은 CPU 자원을 필요로 하는 무거운 처리임
- CBO는 실행 계획 후보 여러 개 생성 > 비용 비교해서 선택
	- 비용: 처리에 필요한 시스템 자원 (디스크 I/O 및 CPU)을 추정한 평가치

**옵티마이저 통계**
옵티마이저 통계(통계 정보)는 테이블의 로우 수, 로우의 평균 크기, 인덱스 유무, B 트리 인덱스의 높이, 칼럼 값의 변동 상태 등 실제로 저장돼 있는 데이터의 상태를 집약한 다양한 통계
- 옵티마이저 통계는 데이터 딕셔너리에 저장
![[SQL 처리 원리-20250107181730066.webp]]
옵티마이저 통계는 데이터베이스 객체(테이블, 인덱스, 열 등)에 대한 정보를 포함하며, 이 정보는 사전에 수집

![[SQL 처리 원리-20250107181706856.webp]]
🐤 쿼리가 날라오면 CBO가 옵티마이저 통게를 참고해서 비용계산해서 가장 싼 실행계획을 선택한다. 근데 그 옵티마이저 통계는 사전에 수집되어있는 통계인데, 수동, 자동, 임시 수집이 가능하다
ex. 옵티마이저는 데이터 분포와 크기를 기반으로 테이블 전체를 스캔할지(Tablescan), 인덱스를 사용할지(Index Scan)를 결정


🥦분석이 끝난 SQL 정보의 저장
SGA > 공유 풀 > 라이브러리 캐시에 아래 목록 저장함. > 재사용하기 위해(SQL 분석시간 단축)
- 실행 가능한 SQL 
- 실행 계획 

참고: 오라클은 문자열이 완전히 동일해야지만 같은 SQL이라고 판단함. > SQL 작성방식 표준화 할 필요있음 (ex. 공백 수, 대소문자, 주석 내용도 같아야함) *티베로도*

공유풀에서 없어지는 경우
- 공유풀에 저장되므로 인스턴스를 정지하면 없어짐.
- 공유풀은 LRU로 관리 되기 때문에 오랫동안 사용하지 않으면 제거될 수 있음 (age out)

##### SQL 실행
분석을 통해 얻은 실행계획대로 실행함.


1. 처리 대상 로우를 포함하는 블록이 데이터 파일에서 데이터베이스 버퍼 캐시에 적재
2.  SQL이 INSERT/UPDATE/DELETE일 때는 데이터베이스 버퍼 캐시의 블록이 실제로 변경됨.
3. SELECT문일 때는 검색되는 로우를 마킹 처리만 함. (실제 데이터를 가져오는 것은 다음 단계인 '로우 가져오기에서 수행)
![[SQL 처리 원리-20250107184224817.webp]]


##### 로우 취득 (select문일 때만)
마킹한 로우의 데이터 갖고 옴
모든 로우를 일괄로 갖고오는 것이 아니라 가능하면 일정한 로우로 분할해 갖고 옴.

// ?? 근데 버퍼 캐시에 데이터 블록 잡채로 저장해두는거 아니었나?

+ORDER BY절이 있으면 정렬 처리함.
+결과 > 세션을통해 클라이언트로 전송

#### 실행 계획 확인해보기
1. 옵티마이저 통계 (수동) 수집
```SQL
C:\>sqlplus /nolog
SQL> connect scott/tiger

SQL> EXECUTE DBMS_STATS.GATHER_SCHEMA_STATS ('SCOTT');

PL/SQL procedure successfully completed.
```

SCOTT 계정이 소유한 오브젝트의 옵티마이저 통계를 DBMS_STATS 패키지에 포함된 GATHER_SCHEMA_STATS 프로시저를 실행해 수동으로 수집

1. 실행 계획 표시하기

```SQL
SET AUTOTRACE ON EXPLAIN

SELECT *
FROM employees
ORDER BY employee_name;
```
![[SQL 처리 원리-20250107193826605.webp]]
**결과 설명**
- 이 쿼리를 실행하는 데에 사용한 실행계획이 표시됨. (1개)
- 그 실행계획에 대한 Operation 들을 나타냄
- 여기서 들여쓰기 뎁스가 가장 깊은 (가장 상세한 작업) 부터 수행함.
- Id=0은 결과를 반환하는 단계임
- 총 cost는 Id=0의 cost가 이 sql의 cost이고, 이 값은 하위 작업들로부터 계산됨(가장 높은값, 누적 등이 아닌 내부에서 특정 규칙을 갖는듯 함)

**출력물 설명**
- Operation(작업): 실행 계획에서 수행되는 특정 작업. 예: 테이블 접근(Table Access), 인덱스 스캔(Index Scan), 조인(Join) 등.
- Cost(비용): 각 작업의 예상 비용을 나타냅니다. 비용이 낮을수록 효율적입니다.
- Rows(행 수): 작업에서 처리되는 예상 행 수.
- Bytes(바이트): 작업에서 처리되는 데이터의 예상 크기.
```
--------------------------------------------------------------------------------
| Id  | Operation           | Name          | Rows  | Bytes | Cost (%CPU) |
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT    |               |   100 |   512 |     5  (20) |
|   1 |  SORT ORDER BY      |               |   100 |   512 |     5  (20) |
|   2 |   TABLE ACCESS FULL | EMPLOYEES     |   100 |   512 |     4  (15) |
--------------------------------------------------------------------------------

```

#### 분석된 SQL 정보의 보관과 공유
Plan 이 공유풀에 저장되는 것 확인하는 실습
1. 공유풀 초기화
2. SQL 실행 > 하드 파싱시키기
3. 공유풀에 분석정보 존재하는지 확인

실습 > 책 246쪽 참고

#### 데이터베이스 버퍼 캐시의 역할과 효과
데이터 파일에서 블록 읽기, 쓰기를 효율화하기 위한 SGA의 영역
- 캐시 기능
- 버퍼 기능

*티베로랑 동일..*

#### 캐시 기능 확인
내용은 쉬움. > 직접 실습해서 PPT 넣으면 좋을듯
책 참고
#### 인덱스 효과
인덱스를 이용해서 읽기 성능을 향상 시키기

#### 정렬 수행과 PGA, 임시 테이블스페이스 
Order By 절을 지정했다면,  회신하기 전 로우를 정렬해야함
👉 PGA, 임시 테이블 스페이스 사용됨.


### 변경 처리 원리
- 데이터 저장: 블록 단위로 분할되어 저장됨
- 변경처리: 데이터 파일에서 블록을 변경하는 것 아님. <font color="#c0504d">체크포인트</font> 시점 등에 데이터 파일에 지연돼 기록함.
  *Why?* 1. 변경 처리의 성능 향상과 2. 트랜잭션의 지속성
  1.  나중에 한꺼번에 기록하는 것으로 디스크 액세스 횟수를 줄여 변경 처리의 성능을 향상
  2. 커밋 시점에 REDO 데이터를 REDO 로그 파일에 작성하는 것으로 트랜잭션의 처리 내용이 유실되는 것을 막음
![[SQL 처리 원리-20250116143830136.webp]]

#### 트랜잭션 실행시 동작
변경처리는 트랜잭션으로 실행됨.

***트랜잭션***
여러 SQL을 모아 둔 작업 단위
- 커밋, 롤백
  트랜잭션 실행 중에 이를 수행해서 작업 확정 / 작업 취소
- 오라클의 트랜잭션은 변경 처리를 수행하는 DML(UPDATE, INSERT, DELETE 등)을 실행했을 때 시작
 
 **Update 처리 했을때의 과정**
 ![[SQL 처리 원리-20250116145418626.webp]] 1. 클라이언트 애플리케이션에서 UPDATE문이 실행되고, 서버 프로세스가 트랜잭션을 시 작한다.
2. 트랜잭션의 변경 전 데이터를 저장하기 위해 UNDO 세그먼트를 트랜잭션에 할당한다.
3. 변경 대상의 로우가 포함된 블록이 데이터 버퍼 캐시에 존재하지 않는 경우, 해당 블록 이 데이터베이스 버퍼 캐시에 적재된다.
4. 실행된 UPDATE문의 변경 내용에 관한 변경 내역이 REDO 로그 버퍼에 생성된다.
5. 변경 이전의 데이터(UNDO 데이터)가 UNDO 세그먼트에 저장된다. 단, 디스크에 기록하 는 것은 뒤에서 설명할 체크 포인트에서 수행된다.
6. 데이터베이스 버퍼 캐시에 있는 블록 내용이 변경된다.

**Commit시**
![[SQL 처리 원리-20250116145624838.webp]]
7. 클라이언트 애플리케이션에서 COMMIT문이 실행된 서버 프로세스가 커밋 처리를 시 작한다.
8. 트랜잭션과 UNDO 세그먼트의 할당이 해제된다.
9. REDO 로그 버퍼에 존재하는 변경 내역(REDO 데이터)이 'LGWR(로그 라이터)'에 의해 디스 크의 REDO 로그 파일에 기록된다.
10. 서버 프로세스에서 클라이언트 애플리케이션에게 커밋 처리의 완료가 통지된다.

*주의: 커밋 시점에 버퍼캐시 -> 데이터파일 기록되지 않음! 그럼언제? 체크포인트!*

#### 체크 포인트
<font color="#c0504d">체크포인트 발생 시점</font>! 버퍼 캐시상에서 변경된 블록 > 데이터 파일에 기록
-> 변경된 블록들을 한번에 가록하여 데이터 파일 변경 횟수를 줄임 (디스크 액세스가 성능에 영향을 주는 것을 줄임)

체크포인트 발생시, 
<font color="#4f81bd">CKPT</font>(CheckPoint Process)에서 <font color="#4f81bd">DBWn</font>(Database Writer Process)에 <font color="#4f81bd">체크 포인트가 발생한 것을 통지</font>
통지받은 <u>DBWn는 데이터베이스 버퍼 캐시에 변경된 블록을 데이터 파일에 기록</u>
![[SQL 처리 원리-20250116190802674.webp]]

특정 시점까지 변경된 데이터가 데이터 파일에 기록되었음을 데이터베이스의 **컨트롤 파일(Control File)**과  **데이터 파일 헤더**에 저장해야함.

> [!3번 과정에서 기록하는 것]
CKPT가 데이터베이스 버퍼 캐시에서 데이터 파일로 기록된 변경 사항을 추적
CKPT는 컨트롤 파일에 정보를 기록함
➡️데이터 파일에 기록된 가장 최신 변경 사항의 SCN(System Change Number)
  ➡️이 SCN은 데이터 파일과 REDO 로그 파일의 동기화를 유지하는 데 사용
➡️어디서부터 REDO 로그를 적용해야 하는지를 결정하는 기준이 됨

**E.G.**
![[SQL 처리 원리-20250116193707639.webp]]
pk1,2 row가 각각 다른 블럭에 있다는 가정.

![[SQL 처리 원리-20250116193725543.webp]]

- 커밋할때마다 디스크에 기록한다면, 데이터 파일 기록횟수: 2번
- 체크포인트 시점에 일괄 기록한다면, 데이터 파일 기록횟수: 1번
변경 대상 블록의 수가 많을수록 체크포인트 효과는 커짐 (*티베로도 동일*)

체크포인트가 발생하지 않더라도 버퍼캐시 여유공간이 부족할떄도 기록됨.

##### 비정상 종료
1. 커밋은 완료. 체크포인트는 이전
![[SQL 처리 원리-20250116194901308.webp]]

Redo 로그파일은 commit 시점에 저장이 되었기 때문에 <font color="#4f81bd">변경한 내용이 손실 될 수가 없음</font>
Redo 로그 파일을 사용해서 복구!
(Redo 로그는 커밋 시점이외에도 여러 상황에 의해 기록될 수 있음 > 책 56쪽 참고)

2. 커밋도 전에 손상됨



#### 트랜잭션 실행시 동작 확인
