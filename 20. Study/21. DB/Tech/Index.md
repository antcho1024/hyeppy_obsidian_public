---
sticker: emoji//1f648
---
- [[#인덱스|인덱스]]
	- [[#인덱스#인덱스 자료구조|인덱스 자료구조]]
	- [[#인덱스#인덱스 생성 시 (단일, 복합)|인덱스 생성 시 (단일, 복합)]]
	- [[#인덱스#재생성, 수정, 삭제|재생성, 수정, 삭제]]
	- [[#인덱스#검색 시 과정|검색 시 과정]]

🐤검색이 많은 컬럼을 뽑아서 따로 저장해두는거임! 추가 저장공간 필요함!

## 인덱스
테이블에 대한 동작의 속도를 높여주는 자료 구조
- 1개의 컬럼 or 여러개의 컬럼을 이용해서 생성 가능
\
### 인덱스 자료구조
- [[해시 테이블]]
	- 정렬과정 필요 없음
	- 속도가 빠르고 구현이 간단. but  부분검색, 범위검색 등을 지원하지 않기 때문에 <font color="#c0504d">잘 사용 X</font>
- B+ Tree 
	- 많이 사용함.

### 인덱스 생성 순서(단일, 복합)
1. <span style="background:rgba(5, 117, 197, 0.2)">명령어 입력</span>
```SQL
CREATE INDEX idx_employee_name ON employees (name ASC);
```
- 기본 옵션 : 오름차순

2. 메타데이터 갱신
	
3. <span style="background:rgba(5, 117, 197, 0.2)">데이터 스캔</span>
   테이블의 모든 데이터 스캔, 인덱스에 포함된 열 값 모두 추출
   
4. <span style="background:rgba(5, 117, 197, 0.2)">정렬</span>
	스캔된 데이터는 인덱스의 유형에 따라 정렬됩니다. 대부분의 인덱스는 정렬된 순서로 데이터를 저장
	ex) B-트리 인덱스의 경우 키 값을 기준으로 데이터를 정렬
	
> [!복합 인덱스 (다중 컬럼 인덱스)일 경우]
> 첫 번째 컬럼을 기준으로 우선 정렬하고, 그 다음으로 두 번째 컬럼을 기준으로 정렬하는 방식으로 진행됨.
> 
> *❓그렇다면 컬럼 순서에는 어떤 차이가 있을지?*
> *ex)* `CREATE INDEX idx1 ON employees (A, B);` , `CREATE INDEX idx2 ON employees (B, A);`
> 전자의 경우 A 컬럼만 사용하는 쿼리와 A, B 컬럼을 사용하는 쿼리에서 효율적
> 후자의 경우 B 컬럼만 사용하는 쿼리와 A, B 컬럼을 사용하는 쿼리에서 효율적

5. <span style="background:rgba(5, 117, 197, 0.2)">인덱스 페이지 생성</span>
	인덱스 페이지 : 실제로 디스크에 저장되는 데이터 블록
	-> 정렬된 데이터가 여기에 삽입됨

6. 인덱스 구조 빌드
	
7. <span style="background:rgba(5, 117, 197, 0.2)">디스크에 저장</span>

### 재생성, 수정, 삭제

- 재생성
B+ TREE 자료구조 특성 상 테이블에 대한 내용이 수정(특히 제거)될 떄 인덱스에서 제거가 되지 않는 상황이 발생할 때가 있습니다.
고로 불필요한 공간을 차지하는 것을 다시 재배치하기 위해 재생성시켜할 때가 있습니다.
바로 아래와 같이 REBUILD를 이용해 재성성 시킬 수 있습니다.
```SQL
ALTER INDEX 인덱스이름 REBUILD;
```

- 수정
```SQL
ALTER INDEX 인덱스이름 RENAME TO 바꿀인덱스이름;
```

- 삭제
```SQL
DROP INDEX 인덱스이름;
```


### 검색 시 과정
1. 쿼리 최적화기
	- **쿼리 분석**: 사용자가 SQL 쿼리를 실행하면, DBMS의 쿼리 최적화기가 쿼리를 분석
	- **최적화 계획 수립**: 최적화기는 가능한 실행 계획을 수립합니다. 이 계획에는 인덱스를 사용할지, 테이블을 풀 스캔할지 등이 포함
2. 인덱스 탐색 (Index Lookup)
3. 실제 데이터 위치 파악
	인덱스 탐색 과정에서 해당 노드에 도달하게 되면 그 노드에는 실제 데이터 위치 (ex 행 ID) 를 확인함
	- 행 ID는 각 테이블 행(레코드)을 고유하게 식별하기 위한 내부 식별자로 노드에 같이 저장됨
4. 참조 값(ex 행 ID)을 사용해서 실제 테이블에서 조회